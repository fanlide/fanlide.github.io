[{"content":"系统 安装及配置 系统安装 在系统选择上，决定 Ubuntu Server， 版本是 24.04.1 LTS。系统安装上没有太多说的，有很多教程，也很简单\n安装 xrog 和 i3-wm 选择稳定的 xrog 和 i3 。方便配置的 i3 可以直接几行就搞定\n1 sudo apt install xorg i3-wm 自动启动 Xorg 和窗口管理器 编辑 .bashrc文件，在文件的末尾添加以下行：\n1 2 3 if [ -z \u0026#34;$DISPLAY\u0026#34; ] \u0026amp;\u0026amp; [ \u0026#34;$(tty)\u0026#34; = \u0026#34;/dev/tty1\u0026#34; ]; then startx fi 这会在你登录后，自动启动 Xorg 和窗口管理器。该脚本检查当前是否在 tty1 控制台（默认终端）上\n配置自动登录 编辑 /etc/systemd/system/getty.target.wants/getty@tty1.service 文件，将 ExecStart 行修改为：\n1 ExecStart=-/sbin/agetty --autologin \u0026lt;your_username\u0026gt; --noclear %I $TERM 其中：\n\u0026lt;your_username\u0026gt;：替换为你想自动登录的用户名。 i3 配置 禁用 i3bar 状态栏 编辑 ~/.config/i3/config，将如下行注释掉：\n1 2 3 # bar { # status_command i3status # } 不禁用底部的状态栏会影响效果，而且系统信息显示在公共的屏幕上太影响体验了\n隐藏鼠标和禁用熄屏锁屏 安装 unclutter：\n1 sudo apt install unclutter 编辑 ~/.config/i3/config，添加如下行：\n1 2 3 exec --no-startup-id unclutter -root # 隐藏鼠标 exec --no-startup-id xset dpms 0 0 0 # 关闭屏幕自动熄屏 exec --no-startup-id xset s off # 关闭屏幕保护 不使用 xset -dpms 来禁用屏幕管理，因为当使用 xset dpms force off 或 xset dpms force on 时，会导致禁用失效\n安装中文字体和 emoji 字体 1 sudo apt install fonts-noto-cjk fonts-noto-color-emoji 浏览器 安装及配置 在浏览器的选择上，优先选择的是 chromium 。但是实际使用后发现，右上角的翻译提示不管如何加启动参数都无法去除，最终选择使用 ungoogled-chromium 。它不带 google 翻译，自然也就不会出现翻译提示。\n安装浏览器 1 2 3 sudo add-apt-repository ppa:xtradeb/apps sudo apt update sudo apt install ungoogled-chromium 创建链接 1 sudo ln -s /usr/bin/ungoogled-chromium /usr/bin/chromium 设置默认全屏启动页面 编辑 ~/.config/i3/config，添加如下行：\n1 exec --no-startup-id chromium --kiosk --hide-scrollbars --disable-extensions --disable-translate --app=\u0026lt;your_url\u0026gt; \u0026lt;your_url\u0026gt;: 你的初始跳转页面 ","date":"2024-12-27T11:59:06+08:00","permalink":"https://mapleafgo.github.io/posts/linux/once-chromium/","title":"构造个开机即打开网页的 Linux"},{"content":"简介 普天同庆！微信终于发布 Linux 版本了！之前日常使用 Linux 环境，总是会使用一段 时间就弃坑，还是生态问题无法与其他系统比。现在由于信创，各家大厂都在积极适配 Linux ，我又决定拿起来试试。\n系统安装 在系统选择上，我的第一选择当然还是 Deepin ，算是国产之光了，现在已经是更新到 23 了\n最终我选择了 EndeavourOS ，在 ArchLinux 基础上提供了更容易的安装方式，且在安装时就可以集成各种桌面环境的系统。它直接使用 ArchLinux 的官方库和 AUR 库，并且最关键的是 ArchLinux 的 wiki 完全适用 EndeavourOS ！\n\u0026hellip;省略安装步骤，安装很简单，根据提示直接下一步下一步就行，桌面环境选择 GNOME 就行（其实是没截图）\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 [mapleafgo@mapleafgo-pan ~]$ fastfetch ./o. mapleafgo@mapleafgo-pan ./sssso- ----------------------- `:osssssss+- OS: EndeavourOS x86_64 `:+sssssssssso/. Kernel: Linux 6.12.1-arch1-1 `-/ossssssssssssso/. Uptime: 1 hour, 1 min `-/+sssssssssssssssso+:` Packages: 1001 (pacman) `-:/+sssssssssssssssssso+/. Shell: bash 5.2.37 `.://osssssssssssssssssssso++- Display (Microstep 24\u0026#34;): 1920x1080 @ 60 Hz in 24\u0026#34; [External] .://+ssssssssssssssssssssssso++: DE: GNOME 47.2 .:///ossssssssssssssssssssssssso++: WM: Mutter (Wayland) `:////ssssssssssssssssssssssssssso+++. WM Theme: HighContrastInverse `-////+ssssssssssssssssssssssssssso++++- Theme: KvLibadwaitaDark# [Qt], HighContrastInverse [GTK2/3/4] `..-+oosssssssssssssssssssssssso+++++/` Icons: Fluent-dark [Qt], Fluent-dark [GTK2/3/4] ./++++++++++++++++++++++++++++++/:. Font: Noto Sans CJK SC (12pt) [Qt], Noto Sans (10pt) [GTK2/3/4] `:::::::::::::::::::::::::------`` Cursor: Bibata-Modern-Ice (24px) Terminal: GNOME Console 47.1 Terminal Font: Source Code Pro (10pt) CPU: 12th Gen Intel(R) Core(TM) i7-12700 (20) @ 4.90 GHz GPU: Intel AlderLake-S GT1 @ 1.50 GHz [Integrated] Memory: 6.13 GiB / 31.09 GiB (20%) Swap: 0 B / 8.00 GiB (0%) Disk (/): 25.83 GiB / 97.87 GiB (26%) - ext4 Disk (/home): 26.45 GiB / 97.87 GiB (27%) - ext4 Local IP (enp3s0): 192.168.1.*/23 Locale: zh_CN.UTF-8 安装后 neovim 编辑器 自带的 nano 用不习惯，直接先安装 neovim\n1 yay -S neovim 安装后你会发现，neovim 内的复制，只能在当前会话中，无法复制粘贴到其他地方，这个时候就需要安装另一个包 wl-clipboard ，wayland 下命令行的复制粘贴支持\n1 yay -S wl-clipboard 当然，这还没完，你还需要开启 neovim 的剪切板功能。将 set clipboard=unnamedplus 写入 /etc/xdg/nvim/sysinit.vim 文件新一行，这样才能全局开启 (我还在 /etc/xdg/nvim/sysinit.vim 加了个显示行号的配置 set number)\n然后在全局变量中配置 nvim 为默认编辑器，编辑 /etc/environment 文件，将 EDITOR 环境变量改为 nvim 。改前 EDITOR=nano 改后 EDITOR=nvim\n这样就可以了\nfcitx5 输入法 之前用 ibus ， fcitx 更新 5 后，就一直安装 fcitx5 了。在 ArchLinux 系的系统安装，只需要安装 fcitx5-im 和 中文组件 fcitx5-chinese-addons ，非常方便， fcitx5-im 直接把 fcitx5 必要的都安装好了\n安装包命令：\n1 yay -S fcitx5-im fcitx5-chinese-addons 配置环境变量：\n将下面三个环境变量写入 /etc/environment 文件，这样便全局可用了\n1 2 3 XMODIFIERS=@im=fcitx GTK_IM_MODULE=fcitx QT_IM_MODULE=fcitx GNOME 扩展安装：\n安装上 Input Method Panel 才能在 GNOME 顶栏上看到当前的输入状态\n到这里，中文输入法的问题解决了\nQT 样式 在 GNOME 下 QT 默认样式特别丑，就拿 fcitx5 的配置应用来说，就丑哭了的那种，一度让我想放弃它。直到我看到了这篇文章 Uniform look for Qt and GTK applications\n按这篇文章里讲的这些方案，我挨个试下来，最终得到如下的效果\n是不是跟 gnome shell 应用一模一样，下面咱们一步一步来\n安装包命令：\n1 yay -S qadwaitadecorations-qt5 qadwaitadecorations-qt6 qt6ct kvantum kvantum-theme-libadwaita-git 配置环境变量：\n将下面环境变量写入 ~/.bash_profile 文件中\n1 2 3 4 # QT Style export QT_WAYLAND_DECORATION=adwaita export QT_QPA_PLATFORM=\u0026#34;wayland;xcb\u0026#34; export QT_QPA_PLATFORMTHEME=qt6ct 配置 Qt6设置 风格\n打开 Qt6设置 工具，配置风格为 kvantum-dark (因为我使用的暗色，所以选 kvantum-dark ，你也可以选 kvantum)，再在图标主题中选择一个图标库。其他可以不用动\n配置 Kvantum Manager\n打开 Kvantum Manager ，点击 变更/删除主题，在 选择一个主题 中选择 KvLibadwaitaDark (这里也是由于我主色调为暗色，你也可以选择 KvLibadwaita ，根据自己情况选择)，最后点击应用此主题，就算配置完成了\n这里配置完你会发现焦点处有个框，非常影响美观，这个可以在 Kvantum Manager 配置。只须在 配置当前主题 \u0026gt; 杂项 \u0026gt; 删除焦点矩形 勾选上这个复选框即可\n统一鼠标样式\n其实安装好包后细心的你应该就发现了，鼠标进入 qt 应用时，样式发生了改变，与系统不统一。其实只需要将下面的环境变量写入 ~/.bash_profile 即可解决\n1 2 3 # 统一鼠标样式 export XCURSOR_THEME=$(gsettings get org.gnome.desktop.interface cursor-theme | tr -d \u0026#34;\u0026#39;\u0026#34;) export XCURSOR_SIZE=$(gsettings get org.gnome.desktop.interface cursor-size) 这会统一整个系统的鼠标样式及其大小\n关于 QT5 应用\nQT5 应用现在还是比较少了，那些包安装又麻烦，我就懒得折腾了。\n但是有些依赖系统 python-pyqt5 展示的应用，它们很多内部其实是做了兼容处理，优先使用 python-pyqt6。所以我们可以安装个 python-pyqt6\n1 yay -S python-pyqt6 到这里，你的 QT 应用应该就与系统统一了\nGnome 好玩儿的扩展 首先上一张我当前安装的所有扩展的列表\nApp Hider *\n用来隐藏应用图标的，可以让应用图标不展示在应用列表里\nAppIndicator and KStatusNotifierItem Support *\n这个可以算是现在 GNOME 必须的，应用托盘图标\nBing Wallpaper\n自动切换Bing壁纸，不一样的壁纸，不一样的心情\nBluetooth Quick Connect\n在顶栏中快速方便的连接蓝牙设备\nBlur my Shell\n给整个 GNOME 环境加上模糊效果，视觉更上一层楼。顶栏、应用等的模糊效果都能设置\nClipboard Indicator *\n剪切板，这个算是现在系统不可或缺的功能吧。可以查看并使用历史复制的\nCHC-E (Custom Hot Corners - Extended) *\n自定义热区，让屏幕的每个角都带上不一样的快捷功能\nGravatar\n让系统用户头像使用 Gravatar 的头像\nInput Method Panel *\n顶栏输入状态展示，这个前面输入法的时候说过，算是系统必装的\nLunar Calendar 农历\n在顶栏的日历中展示中国农历时辰，这个扩展不是装上就能用的，需要根据说明执行脚本才行\nProxy Switcher *\n在顶部操作面板中，快捷的切换代理模式\nSystem Monitor\n在顶栏中监控系统状态，CPU占用，内存占用，交换空间占用，上下网速等\nTailscale QS\n在顶栏操作面板中，快捷的控制 Tailscale\nUser Avatar In Quick Settings\n在顶栏操作面板中展示用户头像\nUser Themes *\n配置主题时，让其可以加载用户目录的主题，在安装来自 pling 的主题时非常有用\n图标库推荐 推荐在 pling 安装主题和图标库\n最好在安装 ocs-url 包后，在 pling 安装主题将自动安装到用户目录，配合 User Themes 扩展，可以直接在 Gnome Tweaks 中进行应用。非常方便\n1 yay -S ocs-url 推荐图标库 Fluent icon theme\n鼠标样式推荐 推荐 Bibata Cursor ，6套颜色可选，使用如下命令安装\n1 yay -S bibata-cursor-theme-bin 安装后，在 Gnome Tweaks 中进行应用\n重要说明 * 在上面美化过程中，配置环境变量后，都需要重启才能应用上。可以用命令 env 查看当前系统环境变量\n常用 yay 命令 最后补充几个常用的 yay 命令，基本这几个就够用了\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 搜索安装 yay {包名} # 直接安装已知全名的包 yay -S {包名} # 级联卸载 yay -Rns {包名} # 清理无用的包 yay -Ycc # 清理安装缓存 yay -Scc # 检查更新 yay -Syu ","date":"2024-12-04T10:10:32+08:00","image":"https://mapleafgo.github.io/posts/linux/gnome_beautify/A51AE26F-8089-4E33-8107-1E0EBEC3A0DE_hu2658888663884040627.png","permalink":"https://mapleafgo.github.io/posts/linux/gnome_beautify/","title":"EndeavourOS Gnome 美化"},{"content":"最近用adb进行调试时遇到了连不上的问题，之前的设备只需要执行adb connect [ip:host]就能直接连上，今天各种试都不行，查百度也不行。\n于是我想可能是我的设备android版本是12的原因，最后google了下终于找到了官方教程\n总结一下官方连接教程如下:\nandroid 版本 11 及其以上 开启 wifi 调试 首先在 11 及以上版本中，开启 wifi 调试只需在设置的 开发者选项 里就能直接打开，在开发者选项里开启 无线调试\n使用配对码配对设备 开启 wifi 调试后，这里在设备上点进 无线调试 如图:\n点击 使用配对码配对设备 ，这里会弹出配对码和配对的地址。使用如下命令进行授权配对\n1 adb pair [ip:host] 这里回车后会让你输入配对码，看到 Successfully paired ，就是授权成功了\nadb wifi 连接 在完成上面的配对后，就可以直接进行连接了。连接的地址与端口，在无线调试页面有显示\n1 adb connect [ip:host] 检查连接设备情况 1 adb devices -l 执行命令可以查看当前所有连接的设备，不出意外就可以看到咱们刚连接上的设备了\nandroid 版本 10 及其以下 开启 wifi 调试 这个版本没有系统的开启方法，官方给出的是先用USB连接adb执行以下命令\n1 adb tcpip 5555 adb wifi 连接 设备开启 wifi 调试后，之后就可以拔掉数据线，进行 wifi 调试了 (系统重启后需要重新执行开启步骤) ， wifi 调试连接命令如下:\n1 adb connect [ip:host] 这里 ip 和 host 得是需连接设备的 ip 与端口号，端口号就是上个步骤指定的 5555 端口\n检查连接设备情况 1 adb devices -l 执行命令可以查看当前所有连接的设备，不出意外就可以看到咱们刚连接上的设备了\n","date":"2022-05-17T00:00:00Z","permalink":"https://mapleafgo.github.io/posts/android/android-adb-wifi/","title":"adb wifi 连接调试"},{"content":" 转载自 javadoop \u0026ndash; Java设计模式\n一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。\n设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 Gang of Four (GoF) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。\n有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：\n面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。 职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。 对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。 创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。\n创建型模式 创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。\n简单工厂模式 和名字一样简单，非常简单，直接上代码吧：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class FoodFactory { public static Food makeFood(String name) { if (name.equals(\u0026#34;noodle\u0026#34;)) { Food noodle = new LanZhouNoodle(); noodle.addSpicy(\u0026#34;more\u0026#34;); return noodle; } else if (name.equals(\u0026#34;chicken\u0026#34;)) { Food chicken = new HuangMenChicken(); chicken.addCondiment(\u0026#34;potato\u0026#34;); return chicken; } else { return null; } } } 其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。\n简单地说，简单工厂模式通常就是这样，一个工厂类 XxxFactory，里面有一个静态方法，根据我们不同的参数，返回不同的派生自同一个父类（或实现同一接口）的实例对象。\n我们强调职责单一原则，一个类只提供一种功能，FoodFactory 的功能就是只要负责生产各种 Food。\n工厂模式 简单工厂模式很简单，如果它能满足我们的需要，我觉得就不要折腾了。之所以需要引入工厂模式，是因为我们往往需要使用两个或两个以上的工厂。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public interface FoodFactory { Food makeFood(String name); } public class ChineseFoodFactory implements FoodFactory { @Override public Food makeFood(String name) { if (name.equals(\u0026#34;A\u0026#34;)) { return new ChineseFoodA(); } else if (name.equals(\u0026#34;B\u0026#34;)) { return new ChineseFoodB(); } else { return null; } } } public class AmericanFoodFactory implements FoodFactory { @Override public Food makeFood(String name) { if (name.equals(\u0026#34;A\u0026#34;)) { return new AmericanFoodA(); } else if (name.equals(\u0026#34;B\u0026#34;)) { return new AmericanFoodB(); } else { return null; } } } 其中，ChineseFoodA、ChineseFoodB、AmericanFoodA、AmericanFoodB 都派生自 Food。\n客户端调用：\n1 2 3 4 5 6 7 8 public class APP { public static void main(String[] args) { // 先选择一个具体的工厂 FoodFactory factory = new ChineseFoodFactory(); // 由第一步的工厂产生具体的对象，不同的工厂造出不一样的对象 Food food = factory.makeFood(\u0026#34;A\u0026#34;); } } 虽然都是调用 makeFood(\u0026ldquo;A\u0026rdquo;) 制作 A 类食物，但是，不同的工厂生产出来的完全不一样。\n第一步，我们需要选取合适的工厂，然后第二步基本上和简单工厂一样。\n核心在于，我们需要在第一步选好我们需要的工厂。比如，我们有 LogFactory 接口，实现类有 FileLogFactory 和 KafkaLogFactory，分别对应将日志写入文件和写入 Kafka 中，显然，我们客户端第一步就需要决定到底要实例化 FileLogFactory 还是 KafkaLogFactory，这将决定之后的所有的操作。\n虽然简单，不过我也把所有的构件都画到一张图上，这样读者看着比较清晰：\n抽象工厂模式 当涉及到产品族的时候，就需要引入抽象工厂模式了。\n一个经典的例子是造一台电脑。我们先不引入抽象工厂模式，看看怎么实现。\n因为电脑是由许多的构件组成的，我们将 CPU 和主板进行抽象，然后 CPU 由 CPUFactory 生产，主板由 MainBoardFactory 生产，然后，我们再将 CPU 和主板搭配起来组合在一起，如下图：\n这个时候的客户端调用是这样的：\n1 2 3 4 5 6 7 8 9 10 // 得到 Intel 的 CPU CPUFactory cpuFactory = new IntelCPUFactory(); CPU cpu = intelCPUFactory.makeCPU(); // 得到 AMD 的主板 MainBoardFactory mainBoardFactory = new AmdMainBoardFactory(); MainBoard mainBoard = mainBoardFactory.make(); // 组装 CPU 和主板 Computer computer = new Computer(cpu, mainBoard); 单独看 CPU 工厂和主板工厂，它们分别是前面我们说的工厂模式。这种方式也容易扩展，因为要给电脑加硬盘的话，只需要加一个 HardDiskFactory 和相应的实现即可，不需要修改现有的工厂。\n但是，这种方式有一个问题，那就是如果 Intel 家产的 CPU 和 AMD 产的主板不能兼容使用，那么这代码就容易出错，因为客户端并不知道它们不兼容，也就会错误地出现随意组合。\n下面就是我们要说的产品族的概念，它代表了组成某个产品的一系列附件的集合：\n当涉及到这种产品族的问题的时候，就需要抽象工厂模式来支持了。我们不再定义 CPU 工厂、主板工厂、硬盘工厂、显示屏工厂等等，我们直接定义电脑工厂，每个电脑工厂负责生产所有的设备，这样能保证肯定不存在兼容问题。\n这个时候，对于客户端来说，不再需要单独挑选 CPU厂商、主板厂商、硬盘厂商等，直接选择一家品牌工厂，品牌工厂会负责生产所有的东西，而且能保证肯定是兼容可用的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 public static void main(String[] args) { // 第一步就要选定一个“大厂” ComputerFactory cf = new AmdFactory(); // 从这个大厂造 CPU CPU cpu = cf.makeCPU(); // 从这个大厂造主板 MainBoard board = cf.makeMainBoard(); // 从这个大厂造硬盘 HardDisk hardDisk = cf.makeHardDisk(); // 将同一个厂子出来的 CPU、主板、硬盘组装在一起 Computer result = new Computer(cpu, board, hardDisk); } 当然，抽象工厂的问题也是显而易见的，比如我们要加个显示器，就需要修改所有的工厂，给所有的工厂都加上制造显示器的方法。这有点违反了对修改关闭，对扩展开放这个设计原则。\n单例模式 单例模式用得最多，错得最多。\n饿汉模式最简单：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Singleton { // 首先，将 new Singleton() 堵死 private Singleton() {}; // 创建私有静态实例，意味着这个类第一次使用的时候就会进行创建 private static Singleton instance = new Singleton(); public static Singleton getInstance() { return instance; } // 瞎写一个静态方法。这里想说的是，如果我们只是要调用 Singleton.getDate(...)， // 本来是不想要生成 Singleton 实例的，不过没办法，已经生成了 public static Date getDate(String mode) {return new Date();} } 很多人都能说出饿汉模式的缺点，可是我觉得生产过程中，很少碰到这种情况：你定义了一个单例的类，不需要其实例，可是你却把一个或几个你会用到的静态方法塞到这个类中。\n饱汉模式最容易出错：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 public class Singleton { // 首先，也是先堵死 new Singleton() 这条路 private Singleton() {} // 和饿汉模式相比，这边不需要先实例化出来，注意这里的 volatile，它是必须的 private static volatile Singleton instance = null; public static Singleton getInstance() { if (instance == null) { // 加锁 synchronized (Singleton.class) { // 这一次判断也是必须的，不然会有并发问题 if (instance == null) { instance = new Singleton(); } } } return instance; } } 双重检查，指的是两次检查 instance 是否为 null。\nvolatile 在这里是需要的，希望能引起读者的关注。\n很多人不知道怎么写，直接就在 getInstance() 方法签名上加上 synchronized，这就不多说了，性能太差。\n嵌套类最经典，以后大家就用它吧：\n1 2 3 4 5 6 7 8 9 10 11 public class Singleton3 { private Singleton3() {} // 主要是使用了 嵌套类可以访问外部类的静态属性和静态方法 的特性 private static class Holder { private static Singleton3 instance = new Singleton3(); } public static Singleton3 getInstance() { return Holder.instance; } } 注意，很多人都会把这个嵌套类说成是静态内部类，严格地说，内部类和嵌套类是不一样的，它们能访问的外部类权限也是不一样的。\n最后，我们说一下枚举，枚举很特殊，它在类加载的时候会初始化里面的所有的实例，而且 JVM 保证了它们不会再被实例化，所以它天生就是单例的。\n虽然我们平时很少看到用枚举来实现单例，但是在 RxJava 的源码中，有很多地方都用了枚举来实现单例。\n建造者模式 经常碰见的 XxxBuilder 的类，通常都是建造者模式的产物。建造者模式其实有很多的变种，但是对于客户端来说，我们的使用通常都是一个模式的：\n1 2 Food food = new FoodBuilder().a().b().c().build(); Food food = Food.builder().a().b().c().build(); 套路就是先 new 一个 Builder，然后可以链式地调用一堆方法，最后再调用一次 build() 方法，我们需要的对象就有了。\n来一个中规中矩的建造者模式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 class User { // 下面是“一堆”的属性 private String name; private String password; private String nickName; private int age; // 构造方法私有化，不然客户端就会直接调用构造方法了 private User(String name, String password, String nickName, int age) { this.name = name; this.password = password; this.nickName = nickName; this.age = age; } // 静态方法，用于生成一个 Builder，这个不一定要有，不过写这个方法是一个很好的习惯， // 有些代码要求别人写 new User.UserBuilder().a()...build() 看上去就没那么好 public static UserBuilder builder() { return new UserBuilder(); } public static class UserBuilder { // 下面是和 User 一模一样的一堆属性 private String name; private String password; private String nickName; private int age; private UserBuilder() { } // 链式调用设置各个属性值，返回 this，即 UserBuilder public UserBuilder name(String name) { this.name = name; return this; } public UserBuilder password(String password) { this.password = password; return this; } public UserBuilder nickName(String nickName) { this.nickName = nickName; return this; } public UserBuilder age(int age) { this.age = age; return this; } // build() 方法负责将 UserBuilder 中设置好的属性“复制”到 User 中。 // 当然，可以在 “复制” 之前做点检验 public User build() { if (name == null || password == null) { throw new RuntimeException(\u0026#34;用户名和密码必填\u0026#34;); } if (age \u0026lt;= 0 || age \u0026gt;= 150) { throw new RuntimeException(\u0026#34;年龄不合法\u0026#34;); } // 还可以做赋予”默认值“的功能 if (nickName == null) { nickName = name; } return new User(name, password, nickName, age); } } } 核心是：先把所有的属性都设置给 Builder，然后 build() 方法的时候，将这些属性复制给实际产生的对象。\n看看客户端的调用：\n1 2 3 4 5 6 7 8 9 public class APP { public static void main(String[] args) { User d = User.builder() .name(\u0026#34;foo\u0026#34;) .password(\u0026#34;pAss12345\u0026#34;) .age(25) .build(); } } 说实话，建造者模式的链式写法很吸引人，但是，多写了很多“无用”的 builder 的代码，感觉这个模式没什么用。不过，当属性很多，而且有些必填，有些选填的时候，这个模式会使代码清晰很多。我们可以在 Builder 的构造方法中强制让调用者提供必填字段，还有，在 build() 方法中校验各个参数比在 User 的构造方法中校验，代码要优雅一些。\n题外话，强烈建议读者使用 lombok，用了 lombok 以后，上面的一大堆代码会变成如下这样:\n1 2 3 4 5 6 7 @Builder class User { private String name; private String password; private String nickName; private int age; } 怎么样，省下来的时间是不是又可以干点别的了。\n当然，如果你只是想要链式写法，不想要建造者模式，有个很简单的办法，User 的 getter 方法不变，所有的 setter 方法都让其 return this 就可以了，然后就可以像下面这样调用：\n1 User user = new User().setName(\u0026#34;\u0026#34;).setPassword(\u0026#34;\u0026#34;).setAge(20); 很多人是这么用的，但是笔者觉得其实这种写法非常地不优雅，不是很推荐使用。\n原型模式 这是我要说的创建型模式的最后一个设计模式了。\n原型模式很简单：有一个原型实例，基于这个原型实例产生新的实例，也就是“克隆”了。\nObject 类中有一个 clone() 方法，它用于生成一个新的对象，当然，如果我们要调用这个方法，java 要求我们的类必须先实现 Cloneable 接口，此接口没有定义任何方法，但是不这么做的话，在 clone() 的时候，会抛出 CloneNotSupportedException 异常。\n1 protected native Object clone() throws CloneNotSupportedException; java 的克隆是浅克隆，碰到对象引用的时候，克隆出来的对象和原对象中的引用将指向同一个对象。通常实现深克隆的方法是将对象进行序列化，然后再进行反序列化。\n原型模式了解到这里我觉得就够了，各种变着法子说这种代码或那种代码是原型模式，没什么意义。\n创建型模式总结 创建型模式总体上比较简单，它们的作用就是为了产生实例对象，算是各种工作的第一步了，因为我们写的是面向对象的代码，所以我们第一步当然是需要创建一个对象了。\n简单工厂模式最简单；工厂模式在简单工厂模式的基础上增加了选择工厂的维度，需要第一步选择合适的工厂；抽象工厂模式有产品族的概念，如果各个产品是存在兼容性问题的，就要用抽象工厂模式。单例模式就不说了，为了保证全局使用的是同一对象，一方面是安全性考虑，一方面是为了节省资源；建造者模式专门对付属性很多的那种类，为了让代码更优美；原型模式用得最少，了解和 Object 类中的 clone() 方法相关的知识即可。\n结构型模式 前面创建型模式介绍了创建对象的一些设计模式，这节介绍的结构型模式旨在通过改变代码结构来达到解耦的目的，使得我们的代码容易维护和扩展。\n代理模式 第一个要介绍的代理模式是最常使用的模式之一了，用一个代理来隐藏具体实现类的实现细节，通常还用于在真实的实现的前后添加一部分逻辑。\n既然说是代理，那就要对客户端隐藏真实实现，由代理来负责客户端的所有请求。当然，代理只是个代理，它不会完成实际的业务逻辑，而是一层皮而已，但是对于客户端来说，它必须表现得就是客户端需要的真实实现。\n理解代理这个词，这个模式其实就简单了。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 public interface FoodService { Food makeChicken(); Food makeNoodle(); } public class FoodServiceImpl implements FoodService { public Food makeChicken() { Food f = new Chicken() f.setChicken(\u0026#34;1kg\u0026#34;); f.setSpicy(\u0026#34;1g\u0026#34;); f.setSalt(\u0026#34;3g\u0026#34;); return f; } public Food makeNoodle() { Food f = new Noodle(); f.setNoodle(\u0026#34;500g\u0026#34;); f.setSalt(\u0026#34;5g\u0026#34;); return f; } } // 代理要表现得“就像是”真实实现类，所以需要实现 FoodService public class FoodServiceProxy implements FoodService { // 内部一定要有一个真实的实现类，当然也可以通过构造方法注入 private FoodService foodService = new FoodServiceImpl(); public Food makeChicken() { System.out.println(\u0026#34;我们马上要开始制作鸡肉了\u0026#34;); // 如果我们定义这句为核心代码的话，那么，核心代码是真实实现类做的， // 代理只是在核心代码前后做些“无足轻重”的事情 Food food = foodService.makeChicken(); System.out.println(\u0026#34;鸡肉制作完成啦，加点胡椒粉\u0026#34;); // 增强 food.addCondiment(\u0026#34;pepper\u0026#34;); return food; } public Food makeNoodle() { System.out.println(\u0026#34;准备制作拉面~\u0026#34;); Food food = foodService.makeNoodle(); System.out.println(\u0026#34;制作完成啦\u0026#34;) return food; } } 客户端调用，注意，我们要用代理来实例化接口：\n1 2 3 // 这里用代理类来实例化 FoodService foodService = new FoodServiceProxy(); foodService.makeChicken(); 我们发现没有，代理模式说白了就是做 “方法包装” 或做 “方法增强”。在面向切面编程中，其实就是动态代理的过程。比如 Spring 中，我们自己不定义代理类，但是 Spring 会帮我们动态来定义代理，然后把我们定义在 @Before、@After、@Around 中的代码逻辑动态添加到代理中。\n说到动态代理，又可以展开说，Spring 中实现动态代理有两种，一种是如果我们的类定义了接口，如 UserService 接口和 UserServiceImpl 实现，那么采用 JDK 的动态代理，感兴趣的读者可以去看看 java.lang.reflect.Proxy 类的源码；另一种是我们自己没有定义接口的，Spring 会采用 CGLIB 进行动态代理，它是一个 jar 包，性能还不错。\n适配器模式 说完代理模式，说适配器模式，是因为它们很相似，这里可以做个比较。\n适配器模式做的就是，有一个接口需要实现，但是我们现成的对象都不满足，需要加一层适配器来进行适配。\n适配器模式总体来说分三种：默认适配器模式、对象适配器模式、类适配器模式。先不急着分清楚这几个，先看看例子再说。\n默认适配器模式 首先，我们先看看最简单的适配器模式 默认适配器模式(Default Adapter) 是怎么样的。\n我们用 Appache commons-io 包中的 FileAlterationListener 做例子，此接口定义了很多的方法，用于对文件或文件夹进行监控，一旦发生了对应的操作，就会触发相应的方法。\n1 2 3 4 5 6 7 8 9 10 public interface FileAlterationListener { void onStart(final FileAlterationObserver observer); void onDirectoryCreate(final File directory); void onDirectoryChange(final File directory); void onDirectoryDelete(final File directory); void onFileCreate(final File file); void onFileChange(final File file); void onFileDelete(final File file); void onStop(final FileAlterationObserver observer); } 此接口的一大问题是抽象方法太多了，如果我们要用这个接口，意味着我们要实现每一个抽象方法，如果我们只是想要监控文件夹中的文件创建和文件删除事件，可是我们还是不得不实现所有的方法，很明显，这不是我们想要的。\n所以，我们需要下面的一个适配器，它用于实现上面的接口，但是所有的方法都是空方法，这样，我们就可以转而定义自己的类来继承下面这个类即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class FileAlterationListenerAdaptor implements FileAlterationListener { public void onStart(final FileAlterationObserver observer) { } public void onDirectoryCreate(final File directory) { } public void onDirectoryChange(final File directory) { } public void onDirectoryDelete(final File directory) { } public void onFileCreate(final File file) { } public void onFileChange(final File file) { } public void onFileDelete(final File file) { } public void onStop(final FileAlterationObserver observer) { } } 比如我们可以定义以下类，我们仅仅需要实现我们想实现的方法就可以了：\n1 2 3 4 5 6 7 8 9 10 11 public class FileMonitor extends FileAlterationListenerAdaptor { public void onFileCreate(final File file) { // 文件创建 doSomething(); } public void onFileDelete(final File file) { // 文件删除 doSomething(); } } 当然，上面说的只是适配器模式的其中一种，也是最简单的一种，无需多言。下面，再介绍 “正统的” 适配器模式。\n对象适配器模式 来看一个《Head First 设计模式》中的一个例子，我稍微修改了一下，看看怎么将鸡适配成鸭，这样鸡也能当鸭来用。因为，现在鸭这个接口，我们没有合适的实现类可以用，所以需要适配器。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public interface Duck { public void quack(); // 鸭的呱呱叫 public void fly(); // 飞 } public interface Cock { public void gobble(); // 鸡的咕咕叫 public void fly(); // 飞 } public class WildCock implements Cock { public void gobble() { System.out.println(\u0026#34;咕咕叫\u0026#34;); } public void fly() { System.out.println(\u0026#34;鸡也会飞哦\u0026#34;); } } 鸭接口有 fly() 和 quare() 两个方法，鸡 Cock 如果要冒充鸭，fly() 方法是现成的，但是鸡不会鸭的呱呱叫，没有 quack() 方法。这个时候就需要适配了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 毫无疑问，首先，这个适配器肯定需要 implements Duck，这样才能当做鸭来用 public class CockAdapter implements Duck { Cock cock; // 构造方法中需要一个鸡的实例，此类就是将这只鸡适配成鸭来用 public CockAdapter(Cock cock) { this.cock = cock; } // 实现鸭的呱呱叫方法 @Override public void quack() { // 内部其实是一只鸡的咕咕叫 cock.gobble(); } @Override public void fly() { cock.fly(); } } 客户端调用很简单了：\n1 2 3 4 5 6 7 public static void main(String[] args) { // 有一只野鸡 Cock wildCock = new WildCock(); // 成功将野鸡适配成鸭 Duck duck = new CockAdapter(wildCock); ... } 到这里，大家也就知道了适配器模式是怎么回事了。无非是我们需要一只鸭，但是我们只有一只鸡，这个时候就需要定义一个适配器，由这个适配器来充当鸭，但是适配器里面的方法还是由鸡来实现的。\n我们用一个图来简单说明下：\n上图应该还是很容易理解的，我就不做更多的解释了。下面，我们看看类适配模式怎么样的。\n类适配器模式 废话少说，直接上图：\n看到这个图，大家应该很容易理解的吧，通过继承的方法，适配器自动获得了所需要的大部分方法。这个时候，客户端使用更加简单，直接 Target t = new SomeAdapter(); 就可以了。\n适配器模式总结 类适配和对象适配的异同\n一个采用继承，一个采用组合；\n类适配属于静态实现，对象适配属于组合的动态实现，对象适配需要多实例化一个对象。\n总体来说，对象适配用得比较多。\n适配器模式和代理模式的异同\n比较这两种模式，其实是比较对象适配器模式和代理模式，在代码结构上，它们很相似，都需要一个具体的实现类的实例。但是它们的目的不一样，代理模式做的是增强原方法的活；适配器做的是适配的活，为的是提供“把鸡包装成鸭，然后当做鸭来使用”，而鸡和鸭它们之间原本没有继承关系。\n桥梁模式 理解桥梁模式，其实就是理解代码抽象和解耦。\n我们首先需要一个桥梁，它是一个接口，定义提供的接口方法。\n1 2 3 public interface DrawAPI { public void draw(int radius, int x, int y); } 然后是一系列实现类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class RedPen implements DrawAPI { @Override public void draw(int radius, int x, int y) { System.out.println(\u0026#34;用红色笔画图，radius:\u0026#34; + radius + \u0026#34;, x:\u0026#34; + x + \u0026#34;, y:\u0026#34; + y); } } public class GreenPen implements DrawAPI { @Override public void draw(int radius, int x, int y) { System.out.println(\u0026#34;用绿色笔画图，radius:\u0026#34; + radius + \u0026#34;, x:\u0026#34; + x + \u0026#34;, y:\u0026#34; + y); } } public class BluePen implements DrawAPI { @Override public void draw(int radius, int x, int y) { System.out.println(\u0026#34;用蓝色笔画图，radius:\u0026#34; + radius + \u0026#34;, x:\u0026#34; + x + \u0026#34;, y:\u0026#34; + y); } } 定义一个抽象类，此类的实现类都需要使用 DrawAPI：\n1 2 3 4 5 6 7 public abstract class Shape { protected DrawAPI drawAPI; protected Shape(DrawAPI drawAPI) { this.drawAPI = drawAPI; } public abstract void draw(); } 定义抽象类的子类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 // 圆形 public class Circle extends Shape { private int radius; public Circle(int radius, DrawAPI drawAPI) { super(drawAPI); this.radius = radius; } public void draw() { drawAPI.draw(radius, 0, 0); } } // 长方形 public class Rectangle extends Shape { private int x; private int y; public Rectangle(int x, int y, DrawAPI drawAPI) { super(drawAPI); this.x = x; this.y = y; } public void draw() { drawAPI.draw(0, x, y); } } 最后，我们来看客户端演示：\n1 2 3 4 5 6 public static void main(String[] args) { Shape greenCircle = new Circle(10, new GreenPen()); Shape redRectangle = new Rectangle(4, 8, new RedPen()); greenCircle.draw(); redRectangle.draw(); } 可能大家看上面一步步还不是特别清晰，我把所有的东西整合到一张图上：\n这回大家应该就知道抽象在哪里，怎么解耦了吧。桥梁模式的优点也是显而易见的，就是非常容易进行扩展。\n本节引用了这里的例子，并对其进行了修改。\n装饰模式 要把装饰模式说清楚明白，不是件容易的事情。也许读者知道 Java IO 中的几个类是典型的装饰模式的应用，但是读者不一定清楚其中的关系，也许看完就忘了，希望看完这节后，读者可以对其有更深的感悟。\n首先，我们先看一个简单的图，看这个图的时候，了解下层次结构就可以了：\n我们来说说装饰模式的出发点，从图中可以看到，接口 Component 其实已经有了 ConcreteComponentA 和 ConcreteComponentB 两个实现类了，但是，如果我们要增强这两个实现类的话，我们就可以采用装饰模式，用具体的装饰器来装饰实现类，以达到增强的目的。\n从名字来简单解释下装饰器。既然说是装饰，那么往往就是添加小功能这种，而且，我们要满足可以添加多个小功能。最简单的，代理模式就可以实现功能的增强，但是代理不容易实现多个功能的增强，当然你可以说用代理包装代理的多层包装方式，但是那样的话代码就复杂了。\n首先明白一些简单的概念，从图中我们看到，所有的具体装饰者们ConcreteDecorator都可以作为 Component 来使用，因为它们都实现了 Component 中的所有接口。它们和 Component 实现类 ConcreteComponent 的区别是，它们只是装饰者，起装饰作用，也就是即使它们看上去牛逼轰轰，但是它们都只是在具体的实现中加了层皮来装饰而已。\n注意这段话中混杂在各个名词中的 Component 和 Decorator，别搞混了。\n下面来看看一个例子，先把装饰模式弄清楚，然后再介绍下 java io 中的装饰模式的应用。\n最近大街上流行起来了“快乐柠檬”，我们把快乐柠檬的饮料分为三类：红茶、绿茶、咖啡，在这三大类的基础上，又增加了许多的口味，什么金桔柠檬红茶、金桔柠檬珍珠绿茶、芒果红茶、芒果绿茶、芒果珍珠红茶、烤珍珠红茶、烤珍珠芒果绿茶、椰香胚芽咖啡、焦糖可可咖啡等等，每家店都有很长的菜单，但是仔细看下，其实原料也没几样，但是可以搭配出很多组合，如果顾客需要，很多没出现在菜单中的饮料他们也是可以做的。\n在这个例子中，红茶、绿茶、咖啡是最基础的饮料，其他的像金桔柠檬、芒果、珍珠、椰果、焦糖等都属于装饰用的。当然，在开发中，我们确实可以像门店一样，开发这些类：LemonBlackTea、LemonGreenTea、MangoBlackTea、MangoLemonGreenTea\u0026hellip;\u0026hellip;但是，很快我们就发现，这样子干肯定是不行的，这会导致我们需要组合出所有的可能，而且如果客人需要在红茶中加双份柠檬怎么办？三份柠檬怎么办？\n不说废话了，上代码。\n首先，定义饮料抽象基类：\n1 2 3 4 5 6 public abstract class Beverage { // 返回描述 public abstract String getDescription(); // 返回价格 public abstract double cost(); } 然后是三个基础饮料实现类，红茶、绿茶和咖啡：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 public class BlackTea extends Beverage { public String getDescription() { return \u0026#34;红茶\u0026#34;; } public double cost() { return 10; } } public class GreenTea extends Beverage { public String getDescription() { return \u0026#34;绿茶\u0026#34;; } public double cost() { return 11; } } ...// 咖啡省略 定义调料，也就是装饰者的基类，此类必须继承自 Beverage：\n1 2 3 // 调料 public abstract class Condiment extends Beverage { } 然后我们来定义柠檬、芒果等具体的调料，它们属于装饰者，毫无疑问，这些调料肯定都需要继承调料 Condiment 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 public class Lemon extends Condiment { private Beverage bevarage; // 这里很关键，需要传入具体的饮料，如需要传入没有被装饰的红茶或绿茶， // 当然也可以传入已经装饰好的芒果绿茶，这样可以做芒果柠檬绿茶 public Lemon(Beverage bevarage) { this.bevarage = bevarage; } public String getDescription() { // 装饰 return bevarage.getDescription() + \u0026#34;, 加柠檬\u0026#34;; } public double cost() { // 装饰 return beverage.cost() + 2; // 加柠檬需要 2 元 } } public class Mango extends Condiment { private Beverage bevarage; public Mango(Beverage bevarage) { this.bevarage = bevarage; } public String getDescription() { return bevarage.getDescription() + \u0026#34;, 加芒果\u0026#34;; } public double cost() { return beverage.cost() + 3; // 加芒果需要 3 元 } } ...// 给每一种调料都加一个类 看客户端调用：\n1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { // 首先，我们需要一个基础饮料，红茶、绿茶或咖啡 Beverage beverage = new GreenTea(); // 开始装饰 beverage = new Lemon(beverage); // 先加一份柠檬 beverage = new Mongo(beverage); // 再加一份芒果 System.out.println(beverage.getDescription() + \u0026#34; 价格：￥\u0026#34; + beverage.cost()); //\u0026#34;绿茶, 加柠檬, 加芒果 价格：￥16\u0026#34; } 如果我们需要 芒果-珍珠-双份柠檬-红茶：\n1 Beverage beverage = new Mongo(new Pearl(new Lemon(new Lemon(new BlackTea())))); 是不是很变态？\n看看下图可能会清晰一些：\n到这里，大家应该已经清楚装饰模式了吧。\n下面，我们再来说说 java IO 中的装饰模式。看下图 InputStream 派生出来的部分类：\n我们知道 InputStream 代表了输入流，具体的输入来源可以是文件（FileInputStream）、管道（PipedInputStream）、数组（ByteArrayInputStream）等，这些就像前面奶茶的例子中的红茶、绿茶，属于基础输入流。\nFilterInputStream 承接了装饰模式的关键节点，它的实现类是一系列装饰器，比如 BufferedInputStream 代表用缓冲来装饰，也就使得输入流具有了缓冲的功能，LineNumberInputStream 代表用行号来装饰，在操作的时候就可以取得行号了，DataInputStream 的装饰，使得我们可以从输入流转换为 java 中的基本类型值。\n当然，在 java IO 中，如果我们使用装饰器的话，就不太适合面向接口编程了，如：\n1 InputStream inputStream = new LineNumberInputStream(new BufferedInputStream(new FileInputStream(\u0026#34;\u0026#34;))); 这样的结果是，InputStream 还是不具有读取行号的功能，因为读取行号的方法定义在 LineNumberInputStream 类中。\n我们应该像下面这样使用：\n1 2 3 4 5 DataInputStream is = new DataInputStream( new BufferedInputStream( new FileInputStream(\u0026#34;\u0026#34;) ) ); 所以说嘛，要找到纯的严格符合设计模式的代码还是比较难的。\n门面模式 门面模式（也叫外观模式，Facade Pattern）在许多源码中有使用，比如 slf4j 就可以理解为是门面模式的应用。这是一个简单的设计模式，我们直接上代码再说吧。\n首先，我们定义一个接口：\n1 2 3 public interface Shape { void draw(); } 定义几个实现类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class Circle implements Shape { @Override public void draw() { System.out.println(\u0026#34;Circle::draw()\u0026#34;); } } public class Rectangle implements Shape { @Override public void draw() { System.out.println(\u0026#34;Rectangle::draw()\u0026#34;); } } 客户端调用：\n1 2 3 4 5 6 7 8 9 public static void main(String[] args) { // 画一个圆形 Shape circle = new Circle(); circle.draw(); // 画一个长方形 Shape rectangle = new Rectangle(); rectangle.draw(); } 以上是我们常写的代码，我们需要画圆就要先实例化圆，画长方形就需要先实例化一个长方形，然后再调用相应的 draw() 方法。\n下面，我们看看怎么用门面模式来让客户端调用更加友好一些。\n我们先定义一个门面：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 public class ShapeMaker { private Shape circle; private Shape rectangle; private Shape square; public ShapeMaker() { circle = new Circle(); rectangle = new Rectangle(); square = new Square(); } /** * 下面定义一堆方法，具体应该调用什么方法，由这个门面来决定 */ public void drawCircle(){ circle.draw(); } public void drawRectangle(){ rectangle.draw(); } public void drawSquare(){ square.draw(); } } 看看现在客户端怎么调用：\n1 2 3 4 5 6 7 8 public static void main(String[] args) { ShapeMaker shapeMaker = new ShapeMaker(); // 客户端调用现在更加清晰了 shapeMaker.drawCircle(); shapeMaker.drawRectangle(); shapeMaker.drawSquare();\t} 门面模式的优点显而易见，客户端不再需要关注实例化时应该使用哪个实现类，直接调用门面提供的方法就可以了，因为门面类提供的方法的方法名对于客户端来说已经很友好了。\n组合模式 组合模式用于表示具有层次结构的数据，使得我们对单个对象和组合对象的访问具有一致性。\n直接看一个例子吧，每个员工都有姓名、部门、薪水这些属性，同时还有下属员工集合（虽然可能集合为空），而下属员工和自己的结构是一样的，也有姓名、部门这些属性，同时也有他们的下属员工集合。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 public class Employee { private String name; private String dept; private int salary; private List\u0026lt;Employee\u0026gt; subordinates; // 下属 public Employee(String name,String dept, int sal) { this.name = name; this.dept = dept; this.salary = sal; subordinates = new ArrayList\u0026lt;Employee\u0026gt;(); } public void add(Employee e) { subordinates.add(e); } public void remove(Employee e) { subordinates.remove(e); } public List\u0026lt;Employee\u0026gt; getSubordinates(){ return subordinates; } public String toString(){ return (\u0026#34;Employee :[ Name : \u0026#34; + name + \u0026#34;, dept : \u0026#34; + dept + \u0026#34;, salary :\u0026#34; + salary+\u0026#34; ]\u0026#34;); } } 通常，这种类需要定义 add(node)、remove(node)、getChildren() 这些方法。\n这说的其实就是组合模式，这种简单的模式我就不做过多介绍了，相信各位读者也不喜欢看我写废话。\n享元模式 英文是 Flyweight Pattern，不知道是谁最先翻译的这个词，感觉这翻译真的不好理解，我们试着强行关联起来吧。Flyweight 是轻量级的意思，享元分开来说就是 共享 元器件，也就是复用已经生成的对象，这种做法当然也就是轻量级的了。\n复用对象最简单的方式是，用一个 HashMap 来存放每次新生成的对象。每次需要一个对象的时候，先到 HashMap 中看看有没有，如果没有，再生成新的对象，然后将这个对象放入 HashMap 中。\n这种简单的代码我就不演示了。\n结构型模式总结 前面，我们说了代理模式、适配器模式、桥梁模式、装饰模式、门面模式、组合模式和享元模式。读者是否可以分别把这几个模式说清楚了呢？在说到这些模式的时候，心中是否有一个清晰的图或处理流程在脑海里呢？\n代理模式是做方法增强的，适配器模式是把鸡包装成鸭这种用来适配接口的，桥梁模式做到了很好的解耦，装饰模式从名字上就看得出来，适合于装饰类或者说是增强类的场景，门面模式的优点是客户端不需要关心实例化过程，只要调用需要的方法即可，组合模式用于描述具有层次结构的数据，享元模式是为了在特定的场景中缓存已经创建的对象，用于提高性能。\n行为型模式 行为型模式关注的是各个类之间的相互作用，将职责划分清楚，使得我们的代码更加地清晰。\n策略模式 策略模式太常用了，所以把它放到最前面进行介绍。它比较简单，我就不废话，直接用代码说事吧。\n下面设计的场景是，我们需要画一个图形，可选的策略就是用红色笔来画，还是绿色笔来画，或者蓝色笔来画。\n首先，先定义一个策略接口：\n1 2 3 public interface Strategy { public void draw(int radius, int x, int y); } 然后我们定义具体的几个策略：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public class RedPen implements Strategy { @Override public void draw(int radius, int x, int y) { System.out.println(\u0026#34;用红色笔画图，radius:\u0026#34; + radius + \u0026#34;, x:\u0026#34; + x + \u0026#34;, y:\u0026#34; + y); } } public class GreenPen implements Strategy { @Override public void draw(int radius, int x, int y) { System.out.println(\u0026#34;用绿色笔画图，radius:\u0026#34; + radius + \u0026#34;, x:\u0026#34; + x + \u0026#34;, y:\u0026#34; + y); } } public class BluePen implements Strategy { @Override public void draw(int radius, int x, int y) { System.out.println(\u0026#34;用蓝色笔画图，radius:\u0026#34; + radius + \u0026#34;, x:\u0026#34; + x + \u0026#34;, y:\u0026#34; + y); } } 使用策略的类：\n1 2 3 4 5 6 7 8 9 10 11 public class Context { private Strategy strategy; public Context(Strategy strategy){ this.strategy = strategy; } public int executeDraw(int radius, int x, int y){ return strategy.draw(radius, x, y); } } 客户端演示：\n1 2 3 4 public static void main(String[] args) { Context context = new Context(new BluePen()); // 使用绿色笔来画 context.executeDraw(10, 0, 0); } 放到一张图上，让大家看得清晰些：\n这个时候，大家有没有联想到结构型模式中的桥梁模式，它们其实非常相似，我把桥梁模式的图拿过来大家对比下：\n要我说的话，它们非常相似，桥梁模式在左侧加了一层抽象而已。桥梁模式的耦合更低，结构更复杂一些。\n观察者模式 观察者模式对于我们来说，真是再简单不过了。无外乎两个操作，观察者订阅自己关心的主题和主题有数据变化后通知观察者们。\n首先，需要定义主题，每个主题需要持有观察者列表的引用，用于在数据变更的时候通知各个观察者：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 public class Subject { private List\u0026lt;Observer\u0026gt; observers = new ArrayList\u0026lt;Observer\u0026gt;(); private int state; public int getState() { return state; } public void setState(int state) { this.state = state; // 数据已变更，通知观察者们 notifyAllObservers(); } // 注册观察者 public void attach(Observer observer) { observers.add(observer); } // 通知观察者们 public void notifyAllObservers() { for (Observer observer : observers) { observer.update(); } } } 定义观察者接口：\n1 2 3 4 public abstract class Observer { protected Subject subject; public abstract void update(); } 其实如果只有一个观察者类的话，接口都不用定义了，不过，通常场景下，既然用到了观察者模式，我们就是希望一个事件出来了，会有多个不同的类需要处理相应的信息。比如，订单修改成功事件，我们希望发短信的类得到通知、发邮件的类得到通知、处理物流信息的类得到通知等。\n我们来定义具体的几个观察者类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 public class BinaryObserver extends Observer { // 在构造方法中进行订阅主题 public BinaryObserver(Subject subject) { this.subject = subject; // 通常在构造方法中将 this 发布出去的操作一定要小心 this.subject.attach(this); } // 该方法由主题类在数据变更的时候进行调用 @Override public void update() { String result = Integer.toBinaryString(subject.getState()); System.out.println(\u0026#34;订阅的数据发生变化，新的数据处理为二进制值为：\u0026#34; + result); } } public class HexaObserver extends Observer { public HexaObserver(Subject subject) { this.subject = subject; this.subject.attach(this); } @Override public void update() { String result = Integer.toHexString(subject.getState()).toUpperCase(); System.out.println(\u0026#34;订阅的数据发生变化，新的数据处理为十六进制值为：\u0026#34; + result); } } 客户端使用也非常简单：\n1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { // 先定义一个主题 Subject subject1 = new Subject(); // 定义观察者 new BinaryObserver(subject1); new HexaObserver(subject1); // 模拟数据变更，这个时候，观察者们的 update 方法将会被调用 subject.setState(11); } output:\n1 2 订阅的数据发生变化，新的数据处理为二进制值为：1011 订阅的数据发生变化，新的数据处理为十六进制值为：B 当然，jdk 也提供了相似的支持，具体的大家可以参考 java.util.Observable 和 java.util.Observer 这两个类。\n实际生产过程中，观察者模式往往用消息中间件来实现，如果要实现单机观察者模式，笔者建议读者使用 Guava 中的 EventBus，它有同步实现也有异步实现，本文主要介绍设计模式，就不展开说了。\n还有，即使是上面的这个代码，也会有很多变种，大家只要记住核心的部分，那就是一定有一个地方存放了所有的观察者，然后在事件发生的时候，遍历观察者，调用它们的回调函数。\n责任链模式 责任链通常需要先建立一个单向链表，然后调用方只需要调用头部节点就可以了，后面会自动流转下去。比如流程审批就是一个很好的例子，只要终端用户提交申请，根据申请的内容信息，自动建立一条责任链，然后就可以开始流转了。\n有这么一个场景，用户参加一个活动可以领取奖品，但是活动需要进行很多的规则校验然后才能放行，比如首先需要校验用户是否是新用户、今日参与人数是否有限额、全场参与人数是否有限额等等。设定的规则都通过后，才能让用户领走奖品。\n如果产品给你这个需求的话，我想大部分人一开始肯定想的就是，用一个 List 来存放所有的规则，然后 foreach 执行一下每个规则就好了。不过，读者也先别急，看看责任链模式和我们说的这个有什么不一样？\n首先，我们要定义流程上节点的基类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 public abstract class RuleHandler { // 后继节点 protected RuleHandler successor; public abstract void apply(Context context); public void setSuccessor(RuleHandler successor) { this.successor = successor; } public RuleHandler getSuccessor() { return successor; } } 接下来，我们需要定义具体的每个节点了。\n校验用户是否是新用户：\n1 2 3 4 5 6 7 8 9 10 11 12 public class NewUserRuleHandler extends RuleHandler { public void apply(Context context) { if (context.isNewUser()) { // 如果有后继节点的话，传递下去 if (this.getSuccessor() != null) { this.getSuccessor().apply(context); } } else { throw new RuntimeException(\u0026#34;该活动仅限新用户参与\u0026#34;); } } } 校验用户所在地区是否可以参与：\n1 2 3 4 5 6 7 8 9 10 11 12 public class LocationRuleHandler extends RuleHandler { public void apply(Context context) { boolean allowed = activityService.isSupportedLocation(context.getLocation); if (allowed) { if (this.getSuccessor() != null) { this.getSuccessor().apply(context); } } else { throw new RuntimeException(\u0026#34;非常抱歉，您所在的地区无法参与本次活动\u0026#34;); } } } 校验奖品是否已领完：\n1 2 3 4 5 6 7 8 9 10 11 12 public class LimitRuleHandler extends RuleHandler { public void apply(Context context) { int remainedTimes = activityService.queryRemainedTimes(context); // 查询剩余奖品 if (remainedTimes \u0026gt; 0) { if (this.getSuccessor() != null) { this.getSuccessor().apply(userInfo); } } else { throw new RuntimeException(\u0026#34;您来得太晚了，奖品被领完了\u0026#34;); } } } 客户端：\n1 2 3 4 5 6 7 8 9 10 public static void main(String[] args) { RuleHandler newUserHandler = new NewUserRuleHandler(); RuleHandler locationHandler = new LocationRuleHandler(); RuleHandler limitHandler = new LimitRuleHandler(); // 假设本次活动仅校验地区和奖品数量，不校验新老用户 locationHandler.setSuccessor(limitHandler); locationHandler.apply(context); } 代码其实很简单，就是先定义好一个链表，然后在通过任意一节点后，如果此节点有后继节点，那么传递下去。\n至于它和我们前面说的用一个 List 存放需要执行的规则的做法有什么异同，留给读者自己琢磨吧。\n模板方法模式 在含有继承结构的代码中，模板方法模式是非常常用的。\n通常会有一个抽象类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 public abstract class AbstractTemplate { // 这就是模板方法 public void templateMethod() { init(); apply(); // 这个是重点 end(); // 可以作为钩子方法 } protected void init() { System.out.println(\u0026#34;init 抽象层已经实现，子类也可以选择覆写\u0026#34;); } // 留给子类实现 protected abstract void apply(); protected void end() { } } 模板方法中调用了 3 个方法，其中 apply() 是抽象方法，子类必须实现它，其实模板方法中有几个抽象方法完全是自由的，我们也可以将三个方法都设置为抽象方法，让子类来实现。也就是说，模板方法只负责定义第一步应该要做什么，第二步应该做什么，第三步应该做什么，至于怎么做，由子类来实现。\n我们写一个实现类：\n1 2 3 4 5 6 7 8 9 public class ConcreteTemplate extends AbstractTemplate { public void apply() { System.out.println(\u0026#34;子类实现抽象方法 apply\u0026#34;); } public void end() { System.out.println(\u0026#34;我们可以把 method3 当做钩子方法来使用，需要的时候覆写就可以了\u0026#34;); } } 客户端调用演示：\n1 2 3 4 5 public static void main(String[] args) { AbstractTemplate t = new ConcreteTemplate(); // 调用模板方法 t.templateMethod(); } 代码其实很简单，基本上看到就懂了，关键是要学会用到自己的代码中。\n状态模式 update: 2017-10-19\n废话我就不说了，我们说一个简单的例子。商品库存中心有个最基本的需求是减库存和补库存，我们看看怎么用状态模式来写。\n核心在于，我们的关注点不再是 Context 是该进行哪种操作，而是关注在这个 Context 会有哪些操作。\n定义状态接口：\n1 2 3 public interface State { public void doAction(Context context); } 定义减库存的状态：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class DeductState implements State { public void doAction(Context context) { System.out.println(\u0026#34;商品卖出，准备减库存\u0026#34;); context.setState(this); //... 执行减库存的具体操作 } public String toString() { return \u0026#34;Deduct State\u0026#34;; } } 定义补库存状态：\n1 2 3 4 5 6 7 8 9 10 11 12 13 public class RevertState implements State { public void doAction(Context context) { System.out.println(\u0026#34;给此商品补库存\u0026#34;); context.setState(this); //... 执行加库存的具体操作 } public String toString() { return \u0026#34;Revert State\u0026#34;; } } 前面用到了 context.setState(this)，我们来看看怎么定义 Context 类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 public class Context { private State state; private String name; public Context(String name) { this.name = name; } public void setState(State state) { this.state = state; } public void getState() { return this.state; } } 我们来看下客户端调用，大家就一清二楚了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 public static void main(String[] args) { // 我们需要操作的是 iPhone X Context context = new Context(\u0026#34;iPhone X\u0026#34;); // 看看怎么进行补库存操作 State revertState = new RevertState(); revertState.doAction(context); // 同样的，减库存操作也非常简单 State deductState = new DeductState(); deductState.doAction(context); // 如果需要我们可以获取当前的状态 // context.getState().toString(); } 读者可能会发现，在上面这个例子中，如果我们不关心当前 context 处于什么状态，那么 Context 就可以不用维护 state 属性了，那样代码会简单很多。\n不过，商品库存这个例子毕竟只是个例，我们还有很多实例是需要知道当前 context 处于什么状态的。\n行为型模式总结 行为型模式部分介绍了策略模式、观察者模式、责任链模式、模板方法模式和状态模式，其实，经典的行为型模式还包括备忘录模式、命令模式等，但是它们的使用场景比较有限，而且本文篇幅也挺大了，我就不进行介绍了。\n总结 学习设计模式的目的是为了让我们的代码更加的优雅、易维护、易扩展。这次整理这篇文章，让我重新审视了一下各个设计模式，对我自己而言收获还是挺大的。我想，文章的最大收益者一般都是作者本人，为了写一篇文章，需要巩固自己的知识，需要寻找各种资料，而且，自己写过的才最容易记住，也算是我给读者的建议吧。\n（全文完）\n","date":"2021-08-27T10:41:52+08:00","permalink":"https://mapleafgo.github.io/posts/design-pattern/","title":"设计模式也可以这么简单"},{"content":" 前两天在项目中写 jmeter 测试脚本，项目中唯一 ID 得调用端请求时生成并传送，于是查资料、翻官网文档，终于写出来了。\n示例中我们使用简单的百度翻译的词典 API 请求 json 数据。\n说明下，这里为啥要用 groovy 脚本，因为官网说 groovy 脚本会缓存编译结果，可提高性能。而且 groovy 脚本基本跟 Java 没啥区别\n首先先创建个简单的 HTTP 请求 打开 jmeter 后，先在根节点(Test Plan)下新建个线程组(Thread Group)，默认的线程组配置就够我们本次示例用了 在线程组下新建个 Http 请求(HTTP Request)，再新建个结果树展示(View Results Tree) 配置 Http 请求，首先是协议(Protocol): https ，服务地址(Server Name): fanyi.baidu.com ，请求类型: POST ，Path: /sug 添加个请求参数(Parameters)，点击Add，Name: kw，Value: test 点击运行，或者使用快捷键Ctrl+R，运行结束在结果树中查看结果，看看是否请求成功 在发起请求前，填充数据 首先说说我们要达到的预期，我们要在请求参数中清理掉原本kw参数的test值，填充上新的参数值success\n在写下面的东西前，先附上官方文档，这是 JSR233 前置处理器的文档。\n先在 Http 请求节点下新建个 JSR223 前置处理器(JSR223 PreProcessor)，当然，也可以在同级节点建(不过必须要在请求节点后)，同级建的话，处理器的作用域就是同级节点的所有请求\n选择脚本 groovy\n编写脚本\n1 2 3 4 5 6 // 获取请求参数 def params = sampler.getArguments(); // 获取第一个参数，这里排序跟请求节点的参数顺序挂钩 def kw = params.getArgument(0); // 赋予kw新值 kw.setValue(\u0026#34;success\u0026#34;); 运行测试下请求参数是否已经更改\n写到这里，我真的忍不住想吐槽下，这请求参数藏的够深的啊 😑 官方文档也没写这点，要不是看 API 文档，还真就不一定发现的了 Arguments。官方文档里 Parameters、args、ctx、props都试了，活生生让我试出来的啊 😤！！！\n在请求结束后，对返回的数据进行格式化处理 返回数据的处理，主要是对返回的数据进行解码、Json 格式的缩进展示\n后置处理就方便的多了，在 JSR223 后置处理器(JSR223 PostProcessor)中，有prev参数可直接操作结果集\n同前置处理器一样，先建个 JSR223 后置处理器节点，作用域同前置处理器\n同样，脚本选择groovy\n编写脚本\n1 2 3 4 5 6 7 8 9 10 import groovy.json.JsonOutput; import org.apache.commons.lang3.StringEscapeUtils; // 字符串的形式读取返回数据 def data = prev.getResponseDataAsString(); // 格式化json数据 def json = JsonOutput.prettyPrint(data); // 对数据进行Unicode转中文的解码 def ret = StringEscapeUtils.unescapeJava(json); // 把我们转换后的数据设置为返回结果，编码设置为UTF-8 prev.setResponseData(ret, \u0026#34;UTF-8\u0026#34;); 运行测试结果，完美结束！\n至此整个前置后置的处理就完美了\n","date":"2021-03-04T16:06:29+08:00","permalink":"https://mapleafgo.github.io/posts/jmeter/jsr223/","title":"Jmeter 用脚本处理器对数据进行处理"},{"content":" 1 2 3 FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect); // 关闭引用检测 fastConverter.setFastJsonConfig(fastJsonConfig); ","date":"2020-04-21T00:00:00Z","permalink":"https://mapleafgo.github.io/posts/java/fastjson/ref/","title":"解决 fastjson 输出 $ref 引用问题"},{"content":" 注册https://issues.sonatype.org/账号\n使用 scoop 安装 gpgscoop install gpg\n使用 gpg 生成密钥对\ngpg --full-generate-key\n导出私钥\ngpg --export-secret-keys -o secring.gpg\n发布到 ubuntu 密钥库\ngpg --keyserver keyserver.ubuntu.com --send-keys ***********\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 gpg --full-generate-key gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc. This is free software: you are free to change and redistribute it. There is NO WARRANTY, to the extent permitted by law. 请选择您要使用的密钥类型： (1) RSA 和 RSA （默认） (2) DSA 和 Elgamal (3) DSA（仅用于签名） (4) RSA（仅用于签名） RSA 密钥的长度应在 1024 位与 4096 位之间。 您想要使用的密钥长度？(2048) 请设定这个密钥的有效期限。 0 = 密钥永不过期 \u0026lt;n\u0026gt; = 密钥在 n 天后过期 \u0026lt;n\u0026gt;w = 密钥在 n 周后过期 \u0026lt;n\u0026gt;m = 密钥在 n 月后过期 \u0026lt;n\u0026gt;y = 密钥在 n 年后过期 密钥永远不会过期 这些内容正确吗？ (y/N) y GnuPG 需要构建用户标识以辨认您的密钥。 真实姓名： 电子邮件地址： 注释： 最后重复两次输入Passphase（这个在发布的时候需要，相当于密钥密码） 配置 gradle 文件，这个看官方文档吧\n","date":"2020-03-21T00:00:00Z","permalink":"https://mapleafgo.github.io/posts/gradle/maven-publish/","title":"使用Gradle发布到Maven中央仓库"},{"content":"1、安装 sudo apt install -y ibus ibus-gtk ibus-gtk3 ibus-qt4\n2、使用 im-config 切换输入法引擎 直接一路确定、yes\n到这一步选择 ibus，再一路确定。就搞定了\n常见问题： 旧版本 im-config 因为存在两个 ibus 配置文件，所以 ibus 读取不到。可到/usr/share/im-config/data/目录下删除 23_ibus 的两个文件。再次启动 im-config 就可以了\n","date":"2019-07-16T00:00:00Z","image":"https://mapleafgo.github.io/posts/linux/install_ibus/D736D06C-7B39-4813-A96D-027E2A5F8D2D_hu14343513290813786666.png","permalink":"https://mapleafgo.github.io/posts/linux/install_ibus/","title":"Deepin配置使用ibus输入引擎"},{"content":"最终实现效果： 配置 ssl 证书，http 自动跳转 https。所有 https 请求代理到另外的 http 服务上。\n遇到的问题与解决方式： 1、http 自动跳转 https 这里跳转方式，百度就有好多 下面是腾讯给出的方式，也是大多数采用的方式\n1 2 3 4 5 server { listen 80; server_name www.domain.com; #填写绑定证书的域名 rewrite ^(.*)$ https://$host$1 permanent; #把http的域名请求转成https } 这种方式，我感觉不太直观。于是我使用的是下面这种使用 301 重定向的方法\n1 2 3 4 5 server { listen 80; #可以省略，默认就是80 server_name ***; #域名 return 301 https://$server_name; } 2、https 请求代理到 http 服务上 1 2 3 4 5 6 location / { proxy_pass http://xxx; #代理服务地址 proxy_set_header Host $host; #传输服务器地址 proxy_set_header X-Real-IP $remote_addr; #传输请求地址 proxy_set_header X-Forwarded-Proto $scheme; #传递传输协议（主要就是这个指令） } ","date":"2019-06-30T00:00:00Z","image":"https://mapleafgo.github.io/posts/nginx/proxy/4DC29ACB-678C-4221-AFF1-728A6AB2C449_hu1194742012614792911.png","permalink":"https://mapleafgo.github.io/posts/nginx/proxy/","title":"记一次 nginx 代理问题"}]