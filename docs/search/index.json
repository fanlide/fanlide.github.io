[{"content":" 前两天在项目中写 jmeter 测试脚本，项目中唯一 ID 得调用端请求时生成并传送，于是查资料、翻官网文档，终于写出来了。\n  示例中我们使用简单的百度翻译的词典 API 请求 json 数据。\n 说明下，这里为啥要用 groovy 脚本，因为官网说 groovy 脚本会缓存编译结果，可提高性能。而且 groovy 脚本基本跟 Java 没啥区别\n首先先创建个简单的 HTTP 请求  打开 jmeter 后，先在根节点(Test Plan)下新建个线程组(Thread Group)，默认的线程组配置就够我们本次示例用了 在线程组下新建个 Http 请求(HTTP Request)，再新建个结果树展示(View Results Tree) 配置 Http 请求，首先是协议(Protocol): https ，服务地址(Server Name): fanyi.baidu.com ，请求类型: POST ，Path: /sug 添加个请求参数(Parameters)，点击Add，Name: kw，Value: test 点击运行，或者使用快捷键Ctrl+R，运行结束在结果树中查看结果，看看是否请求成功  在发起请求前，填充数据  首先说说我们要达到的预期，我们要在请求参数中清理掉原本kw参数的test值，填充上新的参数值success\n  在写下面的东西前，先附上官方文档，这是 JSR233 前置处理器的文档。\n   先在 Http 请求节点下新建个 JSR223 前置处理器(JSR223 PreProcessor)，当然，也可以在同级节点建(不过必须要在请求节点后)，同级建的话，处理器的作用域就是同级节点的所有请求\n  选择脚本 groovy\n  编写脚本\n// 获取请求参数 def params = sampler.getArguments(); // 获取第一个参数，这里排序跟请求节点的参数顺序挂钩 def kw = params.getArgument(0); // 赋予kw新值 kw.setValue(\u0026#34;success\u0026#34;);   运行测试下请求参数是否已经更改\n  写到这里，我真的忍不住想吐槽下，这请求参数藏的够深的啊 😑 官方文档也没写这点，要不是看 API 文档，还真就不一定发现的了 Arguments。官方文档里 Parameters、args、ctx、props都试了，活生生让我试出来的啊 😤！！！\n在请求结束后，对返回的数据进行格式化处理  返回数据的处理，主要是对返回的数据进行解码、Json 格式的缩进展示\n  后置处理就方便的多了，在 JSR223 后置处理器(JSR223 PostProcessor)中，有prev参数可直接操作结果集\n   同前置处理器一样，先建个 JSR223 后置处理器节点，作用域同前置处理器\n  同样，脚本选择groovy\n  编写脚本\nimport groovy.json.JsonOutput; import org.apache.commons.lang3.StringEscapeUtils; // 字符串的形式读取返回数据 def data = prev.getResponseDataAsString(); // 格式化json数据 def json = JsonOutput.prettyPrint(data); // 对数据进行Unicode转中文的解码 def ret = StringEscapeUtils.unescapeJava(json); // 把我们转换后的数据设置为返回结果，编码设置为UTF-8 prev.setResponseData(ret, \u0026#34;UTF-8\u0026#34;);   运行测试结果，完美结束！\n  至此整个前置后置的处理就完美了\n","date":"2021-03-04T16:06:29+08:00","permalink":"http://mapleafgo.gitee.io/posts/jmeter/jsr223/","title":"Jmeter 用脚本处理器对数据进行处理"},{"content":"FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect); // 关闭引用检测  fastConverter.setFastJsonConfig(fastJsonConfig); ","date":"2020-04-21T00:00:00Z","permalink":"http://mapleafgo.gitee.io/posts/java/fastjson/ref/","title":"解决 fastjson 输出 $ref 引用问题"},{"content":"  注册https://issues.sonatype.org/账号\n  使用 scoop 安装 gpgscoop install gpg\n  使用 gpg 生成密钥对\ngpg --full-generate-key\n导出私钥\ngpg --export-secret-keys -o secring.gpg\n发布到 ubuntu 密钥库\ngpg --keyserver keyserver.ubuntu.com --send-keys ***********\n gpg --full-generate-key\rgpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc.\rThis is free software: you are free to change and redistribute it.\rThere is NO WARRANTY, to the extent permitted by law.\r请选择您要使用的密钥类型：\r(1) RSA 和 RSA （默认）\r(2) DSA 和 Elgamal\r(3) DSA（仅用于签名）\r(4) RSA（仅用于签名）\rRSA 密钥的长度应在 1024 位与 4096 位之间。\r您想要使用的密钥长度？(2048)\r请设定这个密钥的有效期限。\r0 = 密钥永不过期\r\u0026lt;n\u0026gt; = 密钥在 n 天后过期\r\u0026lt;n\u0026gt;w = 密钥在 n 周后过期\r\u0026lt;n\u0026gt;m = 密钥在 n 月后过期\r\u0026lt;n\u0026gt;y = 密钥在 n 年后过期\r密钥永远不会过期\r这些内容正确吗？ (y/N) y\rGnuPG 需要构建用户标识以辨认您的密钥。\r真实姓名：\r电子邮件地址：\r注释：\r最后重复两次输入Passphase（这个在发布的时候需要，相当于密钥密码）\r  配置 gradle 文件，这个看官方文档吧\n  ","date":"2020-03-21T00:00:00Z","permalink":"http://mapleafgo.gitee.io/posts/gradle/maven-publish/","title":"使用Gradle发布到Maven中央仓库"},{"content":"1、安装 sudo apt install -y ibus ibus-gtk ibus-gtk3 ibus-qt4\n2、使用 im-config 切换输入法引擎 \r\n直接一路确定、yes\n\r\n到这一步选择 ibus，再一路确定。就搞定了\n常见问题： 旧版本 im-config 因为存在两个 ibus 配置文件，所以 ibus 读取不到。可到/usr/share/im-config/data/目录下删除 23_ibus 的两个文件。再次启动 im-config 就可以了\n","date":"2019-07-16T00:00:00Z","image":"http://mapleafgo.gitee.io/posts/linux/install_ibus/D736D06C-7B39-4813-A96D-027E2A5F8D2D_hu953bd577f5e4f1bc4673ecb8d410858f_40726_120x120_fill_box_smart1_2.png","permalink":"http://mapleafgo.gitee.io/posts/linux/install_ibus/","title":"Deepin配置使用ibus输入引擎"},{"content":"最终实现效果： 配置 ssl 证书，http 自动跳转 https。所有 https 请求代理到另外的 http 服务上。\n遇到的问题与解决方式： 1、http 自动跳转 https 这里跳转方式，百度就有好多 下面是腾讯给出的方式，也是大多数采用的方式\nserver {\rlisten 80;\rserver_name www.domain.com; #填写绑定证书的域名\rrewrite ^(.*)$ https://$host$1 permanent; #把http的域名请求转成https\r}\r这种方式，我感觉不太直观。于是我使用的是下面这种使用 301 重定向的方法\nserver {\rlisten 80; #可以省略，默认就是80\rserver_name ***; #域名\rreturn 301 https://$server_name;\r}\r2、https 请求代理到 http 服务上 location / {\rproxy_pass http://xxx; #代理服务地址\rproxy_set_header Host $host; #传输服务器地址\rproxy_set_header X-Real-IP $remote_addr; #传输请求地址\rproxy_set_header X-Forwarded-Proto $scheme; #传递传输协议（主要就是这个指令）\r}\r","date":"2019-06-30T00:00:00Z","image":"http://mapleafgo.gitee.io/posts/nginx/proxy/4DC29ACB-678C-4221-AFF1-728A6AB2C449_hu3115ab95d4286227ea3137d1e3cd6502_4973_120x120_fill_box_smart1_2.png","permalink":"http://mapleafgo.gitee.io/posts/nginx/proxy/","title":"记一次 nginx 代理问题"}]