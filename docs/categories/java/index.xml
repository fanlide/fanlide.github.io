<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Java on 慕枫的leaf</title><link>https://mapleafgo.github.io/categories/java/</link><description>Recent content in Java on 慕枫的leaf</description><generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Fri, 27 Aug 2021 10:41:52 +0800</lastBuildDate><atom:link href="https://mapleafgo.github.io/categories/java/index.xml" rel="self" type="application/rss+xml"/><item><title>设计模式也可以这么简单</title><link>https://mapleafgo.github.io/posts/design-pattern/</link><pubDate>Fri, 27 Aug 2021 10:41:52 +0800</pubDate><guid>https://mapleafgo.github.io/posts/design-pattern/</guid><description>转载自 javadoop &amp;ndash; Java设计模式
一直想写一篇介绍设计模式的文章，让读者可以很快看完，而且一看就懂，看懂就会用，同时不会将各个模式搞混。自认为本文还是写得不错的😂😂😂，花了不少心思来写这文章和做图，力求让读者真的能看着简单同时有所收获。
设计模式是对大家实际工作中写的各种代码进行高层次抽象的总结，其中最出名的当属 Gang of Four (GoF) 的分类了，他们将设计模式分类为 23 种经典的模式，根据用途我们又可以分为三大类，分别为创建型模式、结构型模式和行为型模式。
有一些重要的设计原则在开篇和大家分享下，这些原则将贯通全文：
面向接口编程，而不是面向实现。这个很重要，也是优雅的、可扩展的代码的第一步，这就不需要多说了吧。 职责单一原则。每个类都应该只有一个单一的功能，并且该功能应该由这个类完全封装起来。 对修改关闭，对扩展开放。对修改关闭是说，我们辛辛苦苦加班写出来的代码，该实现的功能和该修复的 bug 都完成了，别人可不能说改就改；对扩展开放就比较好理解了，也就是说在我们写好的代码基础上，很容易实现扩展。 创建型模式比较简单，但是会比较没有意思，结构型和行为型比较有意思。
创建型模式 创建型模式的作用就是创建对象，说到创建一个对象，最熟悉的就是 new 一个对象，然后 set 相关属性。但是，在很多场景下，我们需要给客户端提供更加友好的创建对象的方式，尤其是那种我们定义了类，但是需要提供给其他开发者用的时候。
简单工厂模式 和名字一样简单，非常简单，直接上代码吧：
public class FoodFactory { public static Food makeFood(String name) { if (name.equals(&amp;#34;noodle&amp;#34;)) { Food noodle = new LanZhouNoodle(); noodle.addSpicy(&amp;#34;more&amp;#34;); return noodle; } else if (name.equals(&amp;#34;chicken&amp;#34;)) { Food chicken = new HuangMenChicken(); chicken.addCondiment(&amp;#34;potato&amp;#34;); return chicken; } else { return null; } } } 其中，LanZhouNoodle 和 HuangMenChicken 都继承自 Food。</description></item><item><title>解决 fastjson 输出 $ref 引用问题</title><link>https://mapleafgo.github.io/posts/java/fastjson/ref/</link><pubDate>Tue, 21 Apr 2020 00:00:00 +0000</pubDate><guid>https://mapleafgo.github.io/posts/java/fastjson/ref/</guid><description>FastJsonConfig fastJsonConfig = new FastJsonConfig(); fastJsonConfig.setSerializerFeatures(SerializerFeature.DisableCircularReferenceDetect); // 关闭引用检测 fastConverter.setFastJsonConfig(fastJsonConfig);</description></item><item><title>使用Gradle发布到Maven中央仓库</title><link>https://mapleafgo.github.io/posts/gradle/maven-publish/</link><pubDate>Sat, 21 Mar 2020 00:00:00 +0000</pubDate><guid>https://mapleafgo.github.io/posts/gradle/maven-publish/</guid><description>注册https://issues.sonatype.org/账号
使用 scoop 安装 gpgscoop install gpg
使用 gpg 生成密钥对
gpg --full-generate-key
导出私钥
gpg --export-secret-keys -o secring.gpg
发布到 ubuntu 密钥库
gpg --keyserver keyserver.ubuntu.com --send-keys ***********
gpg --full-generate-key
gpg (GnuPG) 2.2.20; Copyright (C) 2020 Free Software Foundation, Inc.
This is free software: you are free to change and redistribute it.
There is NO WARRANTY, to the extent permitted by law.
请选择您要使用的密钥类型：
(1) RSA 和 RSA （默认）
(2) DSA 和 Elgamal
(3) DSA（仅用于签名）
(4) RSA（仅用于签名）
RSA 密钥的长度应在 1024 位与 4096 位之间。
您想要使用的密钥长度？(2048)
请设定这个密钥的有效期限。
0 = 密钥永不过期
&amp;lt;n&amp;gt; = 密钥在 n 天后过期
&amp;lt;n&amp;gt;w = 密钥在 n 周后过期
&amp;lt;n&amp;gt;m = 密钥在 n 月后过期
&amp;lt;n&amp;gt;y = 密钥在 n 年后过期
密钥永远不会过期
这些内容正确吗？ (y/N) y
GnuPG 需要构建用户标识以辨认您的密钥。
真实姓名：
电子邮件地址：
注释：
最后重复两次输入Passphase（这个在发布的时候需要，相当于密钥密码）
配置 gradle 文件，这个看官方文档吧</description></item></channel></rss>